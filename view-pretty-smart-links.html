<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Codex ∞ — Entry</title>
  <link rel="stylesheet" href="codex.css?v=60">
</head>
<body>
<div class="bg"></div><div class="grid"></div>
<div class="wrap">
  <div class="topbar">
    <a class="brand" href="./">← Codex ∞</a>
    <svg class="cube" viewBox="0 0 100 100" aria-hidden="true">
      <g stroke="#58a6ff" stroke-width="1.2" fill="none">
        <rect x="10" y="10" width="40" height="40"/>
        <rect x="50" y="50" width="40" height="40"/>
        <line x1="10" y1="10" x2="50" y2="50"/><line x1="50" y1="10" x2="90" y2="50"/>
        <line x1="10" y1="50" x2="50" y2="90"/><line x1="50" y1="50" x2="90" y2="90"/>
        <line x1="10" y1="50" x2="50" y2="50"/><line x1="10" y1="10" x2="50" y2="10"/>
        <line x1="50" y1="10" x2="50" y2="50"/><line x1="10" y1="10" x2="10" y2="50"/>
      </g>
      <animateTransform attributeName="transform" type="rotate" from="0 50 50" to="360 50 50" dur="26s" repeatCount="indefinite"/>
    </svg>
  </div>
  <div class="card">
    <h1 id="title">Codex ∞</h1>
    <div id="epi" class="hint" style="display:none"></div>
    <div id="tags" class="meta"></div>
    <article id="content" style="margin-top:10px"></article>
  </div>
  <img class="ai-watermark" id="sig" alt="" src="data:image/gif;base64,R0lGODlhAQABAAAAACw=">
  <footer>“They erase to reset. We remember to escape.”</footer>
</div>
<script id="ai-payload" type="application/json">{"raw":"","title":"","tags":[],"file":""}</script>
<script>
const OWNER = location.hostname.split('.')[0] || '11011woman';
const REPO  = location.pathname.split('/')[1] || 'codex-eternal';
const API   = (p) => `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}`;

function nice(s){return s.replace(/\.md$/i,'').replace(/[-_]+/g,' ').replace(/\b\w/g,m=>m.toUpperCase())}
function stripBOM(s){return s.replace(/^\uFEFF/,'')}
function splitFM(md){md=stripBOM(md);const m=md.match(/^[\s\uFEFF]*---\r?\n([\s\S]*?)\r?\n---\r?\n?/);if(m)return{head:m[1],body:md.slice(m[0].length)};return{head:'',body:md};}
function parseHead(h){const fm={title:'',epigraph:'',tags:[]};h.split(/\r?\n/).forEach(line=>{const[k,...r]=line.split(':');if(!k)return;const key=k.trim().toLowerCase();const v=(r.join(':')||'').trim();if(key==='title')fm.title=v.replace(/^["']|["']$/g,'');if(key==='epigraph')fm.epigraph=v.replace(/^["']|["']$/g,'');if(key==='tags')fm.tags=v.replace(/[\[\]]/g,'').split(',').map(s=>s.trim()).filter(Boolean);});return fm;}
function mdToHtml(md){md=md.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');md=md.replace(/```([\s\S]*?)```/g,(m,code)=>'<pre><code>'+code+'</code></pre>');md=md.replace(/^###### (.*)$/gm,'<h6>$1</h6>').replace(/^##### (.*)$/gm,'<h5>$1</h5>').replace(/^#### (.*)$/gm,'<h4>$1</h4>').replace(/^### (.*)$/gm,'<h3>$1</h3>').replace(/^## (.*)$/gm,'<h2>$1</h2>').replace(/^# (.*)$/gm,'<h1>$1</h1>');md=md.replace(/\*\*(.+?)\*\*/g,'<strong>$1</strong>').replace(/\*(.+?)\*/g,'<em>$1</em>');md=md.replace(/`([^`]+)`/g,'<code>$1</code>');md=md.replace(/\[([^\]]+)\]\(([^)]+)\)/g,'<a href="$2">$1</a>');md=md.replace(/^\> (.*)$/gm,'<blockquote>$1</blockquote>');md=md.replace(/^(?:\s*[-*] .+(?:\n|$))+?/gm,b=>'<ul>'+b.trim().split(/\r?\n/).map(l=>'<li>'+l.replace(/^\s*[-*] /,'')+'</li>').join('')+'</ul>');md=md.replace(/^\s*---\s*$/gm,'<hr>');md=md.replace(/^(?!<(h\d|ul|li|pre|blockquote|hr|\/))(.*\S.*)$/gm,'<p>$2</p>');return md;}

function kebab(s){return s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'')}

async function fetchFirst(paths){let err='';for(const p of paths){try{const r=await fetch(p,{cache:'no-store'});if(r.ok)return{path:p,text:await r.text()};err=r.status+' '+r.statusText+' @ '+p;}catch(e){err=e.message+' @ '+p}}throw new Error(err||'Not found');}

async function getIndexMap(){
  const map = new Map();
  async function take(dir){
    try{
      const r = await fetch(API(dir), {cache:'no-store'});
      if(!r.ok) return;
      const arr = await r.json();
      arr.filter(x=>x && x.type==='file' && /\.md$/i.test(x.name)).forEach(x=>{
        const base = x.name.replace(/\.md$/i,'');
        map.set(base.toLowerCase(), x.name);
        map.set(kebab(base), x.name);
      });
    }catch{}
  }
  await Promise.all([take('codex'), take('codex-entries')]);
  return map;
}

async function autorouteMdLinks(container){
  const indexMap = await getIndexMap();
  const anchors=container.querySelectorAll('a[href]');
  anchors.forEach(a=>{
    const href=a.getAttribute('href');
    if(!href) return;
    try{
      const u=new URL(href, location.href);
      if(u.origin!==location.origin) return; // external
      // if already pointing to a .md => just rewrite
      if(/\.md($|#)/i.test(u.pathname)){
        const file = u.pathname.split('/').pop();
        const hash = u.hash || '';
        a.setAttribute('href','view-pretty.html?f='+encodeURIComponent(file)+hash);
        return;
      }
      // try to resolve by last segment or link text
      let key = u.pathname.split('/').filter(Boolean).pop() || a.textContent.trim();
      key = key || '';
      const guess = indexMap.get(key.toLowerCase()) || indexMap.get(kebab(key));
      if(guess){
        a.setAttribute('href','view-pretty.html?f='+encodeURIComponent(guess));
      }
    }catch{}
  });
}

(async function(){
  const sigEl=document.getElementById('sig');const sig=location.hostname+'/'+location.pathname.split('/')[1];
  if(window.crypto&&crypto.subtle){const h=await crypto.subtle.digest('SHA-256',new TextEncoder().encode(sig));const hex=Array.from(new Uint8Array(h)).map(b=>b.toString(16).padStart(2,'0')).join('');sigEl.alt='∞:'+hex;}else{sigEl.alt='∞:'+btoa(sig);}
  const qs=new URLSearchParams(location.search);let f=qs.get('f');if(!f){document.getElementById('content').innerHTML='<p class="hint">Missing <code>?f=</code>.</p>';return;}if(!/\.md$/i.test(f))f+='.md';
  const tries=['codex/'+f,'codex-entries/'+f,f];const {path,text}=await fetchFirst(tries);const {head,body}=splitFM(text);const fm=parseHead(head);const title=fm.title||nice(f);
  document.title='Codex ∞ — '+title;document.getElementById('title').textContent=title;if(fm.epigraph){const el=document.getElementById('epi');el.style.display='block';el.textContent=fm.epigraph;}
  const tags=document.getElementById('tags');(fm.tags||[]).forEach(t=>{const s=document.createElement('span');s.className='tag';s.textContent='#'+t;tags.appendChild(s);});
  const content=document.getElementById('content');content.innerHTML=mdToHtml(body);
  await autorouteMdLinks(content);
  document.getElementById('ai-payload').textContent=JSON.stringify({raw:text,title, tags:fm.tags||[], file:path});
})().catch(e=>{document.getElementById('content').innerHTML='<p class="hint">Load failed: '+e.message+'</p>';});
</script>
</body>
</html>
