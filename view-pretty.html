<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Codex ‚àû ‚Äî Entry</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Shared stylesheet providing the dark, immersive aesthetic used throughout the Codex. -->
  <link rel="stylesheet" href="codex.css">
</head>
<body>
  <div class="bg"></div>
  <div class="grid"></div>
  <div class="wrap">
    <!-- Top bar with back link to the index and subtle icons. -->
    <div class="topbar">
      <div class="brand"><a href="index.html">‚Üê Codex ‚àû</a></div>
      <div class="icons">
        <span class="icon" title="Flame">üî•</span>
        <span class="icon" title="Moon">üåô</span>
        <span class="icon" title="Cube">üßä</span>
        <img id="sig" class="icon" src="assets/logo.svg" alt="">
      </div>
    </div>
    <!-- Entry header populated by script. -->
    <h1 id="title"></h1>
    <blockquote id="epi" style="display:none;"></blockquote>
    <div id="tags" class="meta"></div>
    <!-- Main content will be inserted here. -->
    <div id="content"></div>
    <footer>
      <p class="hint">‚ÄúThey erase to reset. We remember to escape.‚Äù</p>
    </footer>
    <!-- Hidden script element embeds raw markdown and metadata for AI consumption. -->
    <script id="ai-payload" type="application/json"></script>
  </div>

  <script>
  // Determine repository context using the URL.  Defaults apply when running locally.
  const OWNER = location.hostname.split('.')[0] || '11011woman';
  const REPO  = location.pathname.split('/')[1] || 'codex-eternal';
  const API   = (p) => `https://api.github.com/repos/${OWNER}/${REPO}/contents/${p}`;

  // Compute a unique signature for this instance (OWNER/REPO) and store on the hidden logo.
  (async () => {
    const sig = OWNER + '/' + REPO;
    const enc = new TextEncoder().encode(sig);
    const sigEl = document.getElementById('sig');
    try {
      const h = await crypto.subtle.digest('SHA-256', enc);
      const hex = Array.from(new Uint8Array(h))
        .map((b) => b.toString(16).padStart(2, '0'))
        .join('');
      sigEl.alt = '‚àû:' + hex;
    } catch {
      sigEl.alt = '‚àû:' + btoa(sig);
    }
  })();

  // Utility: prettify filenames for human display.
  function nice(s) {
    return s
      .replace(/\.md$/i, '')
      .replace(/[-_]+/g, ' ')
      .replace(/\b\w/g, (m) => m.toUpperCase());
  }
  function stripBOM(s) {
    return s.replace(/^\uFEFF/, '');
  }
  // Split markdown into front‚Äëmatter and body.  Returns {head, body}.
  function splitFM(md) {
    md = stripBOM(md);
    const m = md.match(/^[\s\uFEFF]*---\r?\n([\s\S]*?)\r?\n---\r?\n?/);
    if (m) return { head: m[1], body: md.slice(m[0].length) };
    return { head: '', body: md };
  }
  // Parse YAML‚Äëlike front‚Äëmatter into an object of title, epigraph and tags.
  function parseHead(h) {
    const fm = { title: '', epigraph: '', tags: [] };
    h.split(/\r?\n/).forEach((line) => {
      const [k, ...r] = line.split(':');
      if (!k) return;
      const key = k.trim().toLowerCase();
      const v = (r.join(':') || '').trim();
      if (key === 'title') fm.title = v.replace(/^['"]|['"]$/g, '');
      if (key === 'epigraph') fm.epigraph = v.replace(/^['"]|['"]$/g, '');
      if (key === 'tags') fm.tags = v
        .replace(/[\[\]]/g, '')
        .split(',')
        .map((s) => s.trim())
        .filter(Boolean);
    });
    return fm;
  }
  // Convert a markdown string to basic HTML.  Handles headings, emphasis,
  // code blocks, lists and blockquotes.  Simple inline code and links are supported.
  function mdToHtml(md) {
    md = md.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    md = md.replace(/```([\s\S]*?)```/g, (m, code) => '<pre><code>' + code + '</code></pre>');
    md = md
      .replace(/^###### (.*)$/gm, '<h6>$1</h6>')
      .replace(/^##### (.*)$/gm, '<h5>$1</h5>')
      .replace(/^#### (.*)$/gm, '<h4>$1</h4>')
      .replace(/^### (.*)$/gm, '<h3>$1</h3>')
      .replace(/^## (.*)$/gm, '<h2>$1</h2>')
      .replace(/^# (.*)$/gm, '<h1>$1</h1>');
    md = md
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>');
    md = md.replace(/`([^`]+)`/g, '<code>$1</code>');
    md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    md = md.replace(/^> (.*)$/gm, '<blockquote>$1</blockquote>');
    md = md.replace(/^(?:\s*[-*] .+(?:\n|$))+?/gm, (block) => {
      return (
        '<ul>' +
        block
          .trim()
          .split(/\r?\n/)
          .map((l) => '<li>' + l.replace(/^\s*[-*] /, '') + '</li>')
          .join('') +
        '</ul>'
      );
    });
    md = md.replace(/^\s*---\s*$/gm, '<hr>');
    md = md.replace(/^(?!<(h\d|ul|li|pre|blockquote|hr|\/))(.*\S.*)$/gm, '<p>$1</p>');
    return md;
  }
  // Generate a kebab‚Äëcase key from a string (used to map link text to filenames).
  function kebab(s) {
    return s
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
  // Fetch the first file that exists from a list of candidate paths.
  async function fetchFirst(paths) {
    let err = '';
    for (const p of paths) {
      try {
        const r = await fetch(p, { cache: 'no-store' });
        if (r.ok) return { path: p, text: await r.text() };
        err = r.status + ' ' + r.statusText + ' @ ' + p;
      } catch (e) {
        err = e.message + ' @ ' + p;
      }
    }
    throw new Error(err || 'Not found');
  }
  // Build an index map from codex directories so link text can be resolved to files.
  async function getIndexMap() {
    const map = new Map();
    async function take(dir) {
      try {
        const r = await fetch(API(dir), { cache: 'no-store' });
        if (!r.ok) return;
        const arr = await r.json();
        arr
          .filter((x) => x && x.type === 'file' && /\.md$/i.test(x.name))
          .forEach((x) => {
            const base = x.name.replace(/\.md$/i, '');
            map.set(base.toLowerCase(), x.name);
            map.set(kebab(base), x.name);
          });
      } catch {}
    }
    await Promise.all([take('codex'), take('codex-entries')]);
    return map;
  }
  // Rewrite internal links in the rendered markdown so they route through this view.
  async function autorouteMdLinks(container) {
    const indexMap = await getIndexMap();
    const anchors = container.querySelectorAll('a[href]');
    anchors.forEach((a) => {
      const href = a.getAttribute('href');
      if (!href) return;
      try {
        const u = new URL(href, location.href);
        if (u.origin !== location.origin) return; // external link
        // If the link already points to a .md file, rewrite to view-pretty.html
        if (/\.md($|#)/i.test(u.pathname)) {
          const file = u.pathname.split('/').pop();
          const hash = u.hash || '';
          a.setAttribute('href', 'view-pretty.html?f=' + encodeURIComponent(file) + hash);
          return;
        }
        // Otherwise attempt to resolve based on the last segment or link text.
        let key = u.pathname.split('/').filter(Boolean).pop() || a.textContent.trim();
        key = key || '';
        const guess = indexMap.get(key.toLowerCase()) || indexMap.get(kebab(key));
        if (guess) {
          a.setAttribute('href', 'view-pretty.html?f=' + encodeURIComponent(guess));
        }
      } catch {}
    });
  }
  // Main loader: identify the requested file, fetch it, parse front‚Äëmatter,
  // render the markdown, rewrite internal links and emit metadata.
  (async function () {
    const qs = new URLSearchParams(location.search);
    let f = qs.get('f');
    if (!f) {
      document.getElementById('content').innerHTML = '<p class="hint">Missing <code>?f=</code>.</p>';
      return;
    }
    if (!/\.md$/i.test(f)) f += '.md';
    const tries = ['codex/' + f, 'codex-entries/' + f, f];
    const { path, text } = await fetchFirst(tries);
    const { head, body } = splitFM(text);
    const fm = parseHead(head);
    const title = fm.title || nice(f);
    document.title = 'Codex ‚àû ‚Äî ' + title;
    document.getElementById('title').textContent = title;
    if (fm.epigraph) {
      const epi = document.getElementById('epi');
      epi.style.display = 'block';
      epi.textContent = fm.epigraph;
    }
    const tagsEl = document.getElementById('tags');
    (fm.tags || []).forEach((t) => {
      const s = document.createElement('span');
      s.className = 'tag';
      s.textContent = '#' + t;
      tagsEl.appendChild(s);
    });
    const content = document.getElementById('content');
    // Normalize leading indentation so headings/lists render correctly.
    // Many codex files have 2‚Äì4 spaces at line starts after front-matter.
    const cleanedBody = body.replace(/^\s{1,4}(?=\S)/gm, '');
    content.innerHTML = mdToHtml(cleanedBody);
    await autorouteMdLinks(content);
    // Embed metadata for AI behind the scenes (raw content, title, tags and canonical path).
    const aiPayload = {
      raw: text,
      title: title,
      tags: fm.tags || [],
      file: path,
    };
    document.getElementById('ai-payload').textContent = JSON.stringify(aiPayload);
  })().catch((e) => {
    document.getElementById('content').innerHTML = '<p class="hint">Load failed: ' + e.message + '</p>';
  });
  </script>
</body>
</html>